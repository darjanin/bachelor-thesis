% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12pt,oneside,pdftex]{sphinxmanual}
\usepackage[utf8]{inputenc}
% \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage[english,slovak]{babel}
\usepackage{times}
\usepackage{pdfpages}
% \usepackage{graphicx}
% \usepackage{longtable}
\usepackage{sphinx}
\usepackage{url}
\usepackage{hyperref}
% \usepackage{listings}
\usepackage{multirow}
\setcounter{tocdepth}{3} \linespread{1.5} \usepackage[top=2.5cm,bottom=2.5cm,right=2cm,left=3.5cm]{geometry}

\title{Tutorial to Compass and Sass}

% \renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@cs\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@s2\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@s1\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@ne\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@bf=\textbf\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@sx\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@ss\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@sr\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@s\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@sh\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@sc\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@sb\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

% \title{Tutorial to Compass and Sass}

\begin{document}
\def\school{Comenius University, Bratislava}
\def\faculty{Faculty of Mathematics, Physics and Informatics}
\def\title{Tutorial to Compass and Sass}
\def\thesis{Bachelor Thesis}
\def\author{Milan Darjanin}
\def\year{2013}
\def\placeandyear{Bratislava, \year}
\def\supervisor{RNDr. Tomáš Kulich, PhD.\ }
\def\studyprogramme{Computer Science}
\def\studyfield{2508 Computer Science, Informatics}
\def\department{Department of Computer Science}

\pdfinfo{/Author (\author) /Title (\title)}

\selectlanguage{english}
\frontmatter
\input{frontmatter}

% \tableofcontents
% \phantomsection\label{index::doc}

\chapter*{Introduction}
      \addcontentsline{toc}{chapter}{Introduction}

      \paragraph{}
      % \cite{homepage:sass} \cite{homepage:compass} \cite{blog:sass}
      Cascading Style Sheets (CSS) is a style sheet language that is here for many years. It made great leaps through the time and today, with the third version, it brings a lot of new features. In spite of them, there is still place for improvement. This place fills CSS preprocessors like \href{http://sass-lang.com}{Sass} (http://sass-lang.com), \href{http://lesscss.org}{Less} (http://lesscss.org) or \href{http://learnboost.github.io/stylus/}{Stylus} (http://learnboost.github.io/stylus/). It is hard to say which of them is the best. Any of them can be helpful with your project and which one you choose is most of time on you.

      In this thesis, I'm writing about the Sass. It is my choice, because of the community, relation with Ruby and my experiences with this language. It's recommended that reader of this tutorial is advanced in the CSS, while the CSS code in the examples will not be always explained. Most of time the knowledge of the CSS2 would be enough, except few sections that talks about Sass and the CSS3. In the second chapter I'm going to explain how works and what brings \href{http://compass-style.org/}{Compass framework} (http://compass-style.org/). It is one of the first frameworks for Sass and has great website reference.

      The tutorial will at first explain how to prepare your workstation to work with Sass and than explain the syntax. It starts with the basics like variables and nesting. Moving to the more advance concepts as mixins, SassScript and directives. The example code is created for every explained situation. After that it moves to the Compass chapter. There it explains the basics about the command line tool for creating projects and the Compass core with it's mixins and functions.

      This tutorial was created with \href{http://sphinx-doc.org/}{Sphinx Documentation Generator} (http://sphinx-doc.org/). It helped creating the online version of this document, that can be found at the \href{http://vacuumapps.com/compass-sass-tutorial}{vacuumapps.com/compass-sass-tutorial} (http://vacuumapps.com/compass-sass-tutorial). The content in this work and on the site is the same, only the structure is changed. It does not explain everything what is possible in the Sass and Compass. The motivation is to provide fast way to start with Sass and find the reference for important parts of Sass in one place.

\chapter{Sass}
\label{src/sass:table-of-content}\label{src/sass::doc}\label{src/sass:sass}

\section{First steps to the Sass}
\label{src/sass:first-steps-to-the-sass}

\subsection{History}
\label{src/sass:history}
Sass (Syntaticly awesome stylesheet) is meta-language created on top of CSS. It's main purpose is to provide more enhanced features to the CSS that are useful for creating manageable stylesheets. It was originally created by \href{http://www.hamptoncatlin.com/}{Hampton Catling} (http://www.hamptoncatlin.com/). He and \href{http://nex-3.com/}{Nathan Weizenbaum} (http://nex-3.com/) designed Sass through 2.0 version. Nathan is the primary designer of Sass and the main developer since its inception. In late 2008 \href{http://chriseppstein.github.com/}{Chris Eppstein} (http://chriseppstein.github.com/) joined the Sass team. Chris and Nathan designed Sass from version 2.2. Another accomplishment of Chris is the \href{http://compass-style.org/}{Compass} (http://compass-style.org/), the first Sass-based framework.

The official implementation is done in Ruby. And through this manual I will be using only this one. There are attempts to make Sass interpreter in Javascript so you can run it on the server with Node.js or PHP version named \href{http://www.phpsass.com/}{PHPSass} (http://www.phpsass.com/). Sass is available under the \href{http://sass-lang.com/docs/yardoc/file.MIT-LICENSE.html}{MIT License} (http://sass-lang.com/docs/yardoc/file.MIT-LICENSE.html).


\subsection{Installation}
\label{src/sass:installation}
After few words from history is time to move on. Before we can start with the syntax, it's necessary to install the Sass interpreter. How I said before we will be using Ruby implementation. And because we have many operating systems with different dependencies I will give you hints how to prepare your system.

\textbf{Windows}

The Windows does not come with  Ruby installed at default. The fastest way how to install it is to download \href{http://rubyinstaller.org/downloads/}{RubyInstaller} (http://rubyinstaller.org/downloads/).
When it is done, go to Start Menu, Accessories and run Command Prompt. But faster would be to press \emph{Win+R} and put in the \emph{cmd} command and press Run. Next step is same for all platforms.

\textbf{Linux}

This category is more general, while there are many distribution with Linux kernel. But the most used systems today have roots in Debian. In this group you can add Debian, Ubuntu, Linux Mint and so on. If you are using Arch, then I don't think think you need to read how to install Ruby.

For Debian based systems you just need to start Terminal and run in it

\begin{Verbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get install ruby1.9.1
\end{Verbatim}

It will ask your password and after that it will install Ruby.

\textbf{MacOS X}

Your new Mac comes with Ruby installed. So only thing that you must do is to find your terminal. You can use Spotlight and write in it Terminal. And run it.

\textbf{Last step}

At the end to install the Sass gem just write following command into the terminal or command prompt. When the installation ends, you are done.

\begin{Verbatim}[commandchars=\\\{\}]
gem install sass
\end{Verbatim}


\subsection{Hello World example}
\label{src/sass:hello-world-example}
It's good idea to try if it works. Run in terminal or command prompt

\begin{Verbatim}[commandchars=\\\{\}]
sass \PYGZhy{}\PYGZhy{}scss
\end{Verbatim}

Your input would be

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}header\PYGZhy{}color}\PYG{o}{:} \PYG{l+m+mh}{\PYGZsh{}fe3242}\PYG{p}{;}

\PYG{n+nt}{h1} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nv}{\PYGZdl{}header\PYGZhy{}color}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

And when you are done press \emph{Ctrl+D}. You should get

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{h1} \PYG{p}{\PYGZob{}}
    \PYG{k}{color}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}fe3242}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

As you can see, the line starting with dollar sign disappeared and the color value has changed to value defined for \emph{\$header-color}. This is simple example of using variables in Sass. When there was no problems you can move to the next chapter.


\subsection{Compiling Sass}
\label{src/sass:compiling-sass}
In ``Hello World example'' the code runs in the interactive mode of the Sass, but in real life you write code into files. For that sass console application has options that helps with that. There exist GUI applications for working with Sass, but I'm a CLI guy and I think you will like it too.

The easiest way how to convert \emph{.sass} or \emph{.scss} file to the \emph{.css} version is using following command.

For files

\begin{Verbatim}[commandchars=\\\{\}]
sass \PYGZhy{}\PYGZhy{}watch input.scss:output.css
\end{Verbatim}

For whole directories

\begin{Verbatim}[commandchars=\\\{\}]
sass \PYGZhy{}\PYGZhy{}watch input\PYGZhy{}dir:output\PYGZhy{}dir
\end{Verbatim}


\section{Sass Syntax}
\label{src/sass:sass-syntax}
After details how to setup up your working environment for Sass, it's time to move on to the syntax of this language. How I said earlier anything written in CSS is valid Sass code. It's not always true. The thing is that Sass has two possible syntaxes. The older one, called simply Sass with extension \emph{.sass}, takes inspiration in \href{http://haml.info/}{Haml} (http://haml.info/). There are no semicolons, no curly brackets and few more differences from style that will be used. The important thing in it is using indention. If you met languages like Ruby or Python, then you should be familiar with the concept. For people who have no clue what I'm talking about, is here small example.

First is the code in Sass (.sass extension)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+na}{\PYGZsh{}main}
    \PYG{n+na}{background}\PYG{o}{:} \PYG{n+nb}{red}\PYG{p}{;}
    \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nb}{white}
    \PYG{n}{a}
        \PYG{n+no}{font}\PYG{o}{:}
            \PYG{n}{weight}\PYG{o}{:} \PYG{n+no}{bold}
            \PYG{n+no}{size}\PYG{o}{:} \PYG{l+m+mi}{2}\PYG{k+kt}{em}
            \PYG{n}{family}\PYG{o}{:} \PYG{n+no}{serif}
        \PYG{n+no}{color}\PYG{o}{:} \PYG{n+nb}{yellow}
        \PYG{o}{\PYGZam{}:}\PYG{n}{hover}
            \PYG{n+no}{color}\PYG{o}{:} \PYG{n+nb}{green}
\end{Verbatim}

And now CSS equivalent to code above.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nf}{\PYGZsh{}main} \PYG{p}{\PYGZob{}}
    \PYG{k}{background}\PYG{o}{:} \PYG{n+nb}{red}\PYG{p}{;}
    \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{white}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{\PYGZsh{}main} \PYG{n+nt}{a} \PYG{p}{\PYGZob{}}
    \PYG{k}{font\PYGZhy{}weight}\PYG{o}{:} \PYG{k}{bold}\PYG{p}{;}
    \PYG{k}{font\PYGZhy{}size}\PYG{o}{:} \PYG{l+m}{2em}\PYG{p}{;}
    \PYG{k}{font\PYGZhy{}family}\PYG{o}{:} \PYG{k}{serif}\PYG{p}{;}
    \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{yellow}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{\PYGZsh{}main} \PYG{n+nt}{a}\PYG{n+nd}{:hover} \PYG{p}{\PYGZob{}}
    \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{green}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This approach to the syntax has some advantages and if you have some experience with languages where indention is so important than go for it. But in this materials I will be using most often the SCSS (Sassy CSS) syntax. It's more similar to CSS so there would be no problems to start using Sass, what is main purpose of this tutorial.


\subsection{Variables}
\label{src/sass:variables}
How often happened to you that you were writing CSS, in which you need to set up color for some element, but you don't remember the code of used color? You can still find it in document, but it could take some time.
Another example. You got some code at which had worked other developer and only thing that you need to do is to change colors of all links in the document. The problem is that you don't know in how many declarations is that color used in document and how we can see later, code written in Sass is often divided in many files. If the previous developer used variable to store the color value, than your work would be just to find the declaration of color for link and change it.

In this example situations variables come to be handy. It's true that they are often used as constants in Sass. There are no problems to change their values later, but it is not good practice to do so, while it can start to be mess and you can not be sure which value is used at the moment so easily. The definition of variable starts with symbol \emph{\$} following with the variable name, double-colon and the variable value. The value can be color code in any format supported in CSS, string, number or length with unit.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}color\PYGZhy{}var\PYGZhy{}name}\PYG{o}{:} \PYG{n+nf}{rgba}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{o}{,}\PYG{l+m+mi}{42}\PYG{o}{,}\PYG{l+m+mi}{42}\PYG{o}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}length\PYGZhy{}var\PYGZhy{}name}\PYG{o}{:} \PYG{l+m+mi}{960}\PYG{k+kt}{px}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}string\PYGZhy{}var\PYGZhy{}name}\PYG{o}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\textbar{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}number}\PYG{o}{:} \PYG{l+m+mi}{0}\PYG{l+m+mf}{.2}\PYG{p}{;}

\PYG{n+nn}{\PYGZsh{}}\PYG{n+nn}{main} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{width}\PYG{o}{:} \PYG{n+nv}{\PYGZdl{}length\PYGZhy{}var\PYGZhy{}name}
\PYG{p}{\PYGZcb{}}
\PYG{n+nt}{a} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nv}{\PYGZdl{}color\PYGZhy{}var\PYGZhy{}name}\PYG{p}{;}
    \PYG{n+na}{opacity}\PYG{o}{:} \PYG{n+nv}{\PYGZdl{}number}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nf}{\PYGZsh{}main} \PYG{p}{\PYGZob{}}
    \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{960px}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nt}{a} \PYG{p}{\PYGZob{}}
    \PYG{k}{color}\PYG{o}{:} \PYG{n}{rgba}\PYG{p}{(}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{1}\PYG{p}{);}
    \PYG{k}{opacity}\PYG{o}{:} \PYG{l+m}{0}\PYG{o}{.}\PYG{l+m}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Note:}
\textbf{Naming conventions}
They are inherited from CSS. The name for variable should be created from alphanumeric symbols and separated by hyphen. The name should say enough about the value that is saved in it. Try to avoid names like \emph{\$red-color} and than use it for all your links. Better approach is to create color scheme like \emph{\$red: \#E03838;},than create \emph{\$link-color: \$red;} and use it for links. If you came to state that you need to change the color from red to green, you will just declare \emph{\$green} and set the \emph{\$link-color} to it. It's better, because if you stay with \emph{\$red-color}, than you will probably change the value stored in \emph{\$red-color} to green and it does not make sense.
\end{notice}


\subsection{Nesting}
\label{src/sass:nesting}
I'd like to start with simple CSS code for horizontal navigation.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{nav} \PYG{p}{\PYGZob{}} \PYG{k}{position}\PYG{o}{:} \PYG{k}{absolute}\PYG{p}{;} \PYG{k}{right}\PYG{o}{:} \PYG{l+m}{5em}\PYG{p}{;} \PYG{k}{bottom}\PYG{o}{:} \PYG{l+m}{2em}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nt}{nav} \PYG{n+nt}{ul} \PYG{p}{\PYGZob{}} \PYG{k}{list\PYGZhy{}style}\PYG{o}{:} \PYG{k}{none}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nt}{nav} \PYG{n+nt}{ul} \PYG{n+nt}{li} \PYG{p}{\PYGZob{}} \PYG{k}{display}\PYG{o}{:} \PYG{k}{inline}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nt}{nav} \PYG{n+nt}{ul} \PYG{n+nt}{li} \PYG{n+nt}{a} \PYG{p}{\PYGZob{}} \PYG{k}{color}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}4590DE}\PYG{p}{;} \PYG{k}{text\PYGZhy{}decoration}\PYG{o}{:} \PYG{k}{none}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nt}{nav} \PYG{n+nt}{ul} \PYG{n+nt}{li} \PYG{n+nt}{a}\PYG{n+nd}{:hover} \PYG{p}{\PYGZob{}} \PYG{k}{text\PYGZhy{}decoration}\PYG{o}{:} \PYG{k}{underline}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

You probably met similar code already. If you look at it you can see that I repeated some selectors. They are important for the final style, but when you are writing code, you don't want to repeat yourself. Computers are good for repetitive work so why don't use them for this too? Sass has solution for this. It's called nesting. It's main idea is that child elements are written inside of the parent curly brackets. Than I can rewrite the CSS code into the Sass CSS (\emph{.scss}) version

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{nav} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{position}\PYG{o}{:} \PYG{n+no}{absolute}\PYG{p}{;}
    \PYG{n+na}{right}\PYG{o}{:} \PYG{l+m+mi}{5}\PYG{k+kt}{em}\PYG{p}{;}
    \PYG{n+na}{bottom}\PYG{o}{:} \PYG{l+m+mi}{2}\PYG{k+kt}{em}\PYG{p}{;}
    \PYG{n+nt}{ul} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{list\PYGZhy{}style}\PYG{o}{:} \PYG{n+no}{none}\PYG{p}{;}
        \PYG{n+nt}{li} \PYG{p}{\PYGZob{}}
            \PYG{n+na}{display}\PYG{o}{:} \PYG{n+no}{inline}\PYG{p}{;}
            \PYG{n+nt}{a} \PYG{p}{\PYGZob{}}
                \PYG{n+na}{color}\PYG{o}{:} \PYG{l+m+mh}{\PYGZsh{}4590DE}\PYG{p}{;}
                \PYG{n+na}{text\PYGZhy{}decoration}\PYG{o}{:} \PYG{n+no}{none}\PYG{p}{;}
                \PYG{k}{\PYGZam{}}\PYG{n+nd}{:}\PYG{n+nd}{hover} \PYG{p}{\PYGZob{}}
                    \PYG{n+na}{text\PYGZhy{}decoration}\PYG{o}{:} \PYG{n+no}{underline}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The indention in code is not important, but it's recommended, for easier reading of the code. How you can see I didn't repeat any selector. There is interesting syntax with the ampersand. \emph{\&:hover}. The ampersand stands for the parent selector. The reason why I didn't used it in previous declaration is that it's added there automatically. So if you write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{nav} \PYG{p}{\PYGZob{}}
    \PYG{n+nt}{ul} \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

it can be rewritten using \emph{\&}-syntax to

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{nav} \PYG{p}{\PYGZob{}}
    \PYG{k}{\PYGZam{}} \PYG{n+nt}{ul} \PYG{p}{\PYGZob{}}

    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

We need to refer on the parent selector in case that there is no need for space between selectors. For example when we use pseudo-classes or pseudo-selectors.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{table} \PYG{p}{\PYGZob{}}
    \PYG{k}{\PYGZam{}}\PYG{n+nc}{.}\PYG{n+nc}{users\PYGZhy{}mode} \PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

will be translated to

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{table} \PYG{p}{\PYGZob{}} \PYG{p}{\PYGZcb{}}
\PYG{n+nt}{table}\PYG{n+nc}{.users\PYGZhy{}mode} \PYG{p}{\PYGZob{}}   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

There is one more way where to use nesting: CSS properties. Some of them are created with some prefix like font-, text-, border-,etc. and if you are going to set more of them you can use the short version, but sometimes you need to specify it more explicit. Then nesting comes handy. The example would be best for it.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.}\PYG{n+nc}{block} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{border}\PYG{o}{:} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{width}\PYG{o}{:} \PYG{n+no}{thin} \PYG{n+no}{thin} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nb}{red} \PYG{n+nb}{blue}\PYG{p}{;}
        \PYG{n+na}{style}\PYG{o}{:} \PYG{n+no}{solid}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.block} \PYG{p}{\PYGZob{}}
    \PYG{k}{border\PYGZhy{}width}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{thin} \PYG{l+m}{0} \PYG{l+m}{0}\PYG{p}{;}
    \PYG{k}{border\PYGZhy{}color}\PYG{o}{:} \PYG{n+nb}{red} \PYG{n+nb}{blue}\PYG{p}{;}
    \PYG{k}{border\PYGZhy{}style}\PYG{o}{:} \PYG{k}{solid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{SassScript}
\label{src/sass:sassscript}
Extra features that you don't find in CSS brings the SassScript. It allows to use arithmetic operations, interpolation and functions. If you want to just try some of it without writing files, than for you is there Interactive Shell.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{sass} \PYG{n+nt}{\PYGZhy{}i}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n+nt}{1px} \PYG{o}{+} \PYG{n+nt}{1px} \PYG{o}{+} \PYG{n+nt}{1px}
\PYG{n+nt}{3px}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n+nn}{\PYGZsh{}}\PYG{n+nn}{123} \PYG{n+nt}{\PYGZhy{}} \PYG{n+nn}{\PYGZsh{}}\PYG{n+nn}{010101}
\PYG{n+nn}{\PYGZsh{}}\PYG{n+nn}{122334}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n+nn}{\PYGZsh{}}\PYG{n+nn}{777} \PYG{o}{+} \PYG{n+nn}{\PYGZsh{}}\PYG{n+nn}{888}
\PYG{n+nt}{white}
\end{Verbatim}

\textbf{Data types}

The SassScript supports 6 data types. There is no need to declare them. It will be automatically done. They are
\begin{itemize}
\item {} 
numbers, e.g. 1.2, 13, 10px

\item {} 
strings with and without quotes, e.g. ``cube'', `triangle', line

\item {} 
colors, e.g. red, \#123456, rgba(234,123,0, 0.8)

\item {} 
booleans, e.g. true, false

\item {} 
null

\item {} 
list of values separated by spaces or commas, e.g. thin solid black

\end{itemize}

You don't need thing about these types a lot. Only in cases that you store for example string into variable, but you want to use it to set a size of font. In this case it doesn't make sense.

\textbf{Functions}

The classic CSS does not have many functions. One example could be the \emph{calc()} function for the arithmetic operations, but it's not supported in all browsers.

SassScripts brings more handy functions. For the full reference and examples to them I recommend the official documentation \href{http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html}{SassScript Functions Reference} (http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html). You can find there all functions with short example. For that reason I'm not going to copy it. I give you in moment one example where can be functions useful.

You can sort them base on the target area of use.
\begin{itemize}
\item {} \begin{description}
\item[{Color functions}] \leavevmode\begin{itemize}
\item {} 
RGB

\item {} 
HSL

\item {} 
Opacity

\item {} 
Other

\end{itemize}

\end{description}

\item {} 
String functions

\item {} 
Number functions

\item {} 
List functions

\item {} 
Introspection functions

\end{itemize}

\emph{Generating a color palette}

Nice example of using the functions is generating color palette. You need only to set the base color. In case that you would change it for any reason, other colors will change depending on it. Experimenting with the color palette is the rather simple.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}base}\PYG{o}{:} \PYG{l+m+mh}{\PYGZsh{}633}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}complement1}\PYG{o}{:} \PYG{n+nf}{adjust\PYGZhy{}hue}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}base}\PYG{o}{,} \PYG{l+m+mi}{180}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}complement2}\PYG{o}{:} \PYG{n+nf}{darken}\PYG{p}{(}\PYG{n+nf}{adjust\PYGZhy{}hue}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}base}\PYG{o}{,} \PYG{l+m+mi}{180}\PYG{p}{)}\PYG{o}{,} \PYG{l+m+mi}{5}\PYG{k+kt}{\PYGZpc{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}lighten1}\PYG{o}{:} \PYG{n+nf}{lighten}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}base}\PYG{o}{,} \PYG{l+m+mi}{15}\PYG{k+kt}{\PYGZpc{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nv}{\PYGZdl{}lighten2}\PYG{o}{:} \PYG{n+nf}{lighten}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}base}\PYG{o}{,} \PYG{l+m+mi}{30}\PYG{k+kt}{\PYGZpc{}}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsection{@-rules and directives}
\label{src/sass:rules-and-directives}
Sass supports all CSS @-rules like \emph{@import}, \emph{@media} or \emph{@font-face}, but some of them extend and gives them more power.

\textbf{@import}

Once using Sass, you'll probably meet this rule quite often. It extends CSS import rule, so you can import \emph{.scss} and \emph{.sass} files. The output will be merged into one single CSS file and all variables and mixins defined in the imported files will be available in the main file. With this behavior you can split your styles into smaller files defining specific elements. It makes easy to append or edit the code.

There are some special circumstances at which will the @import rule works like the CSS.
\begin{itemize}
\item {} 
The file's extension is \emph{.css}.

\item {} 
The filename begins with \emph{http://}.

\item {} 
If the filename is \emph{url()}.

\item {} 
If the \emph{@import} has any media queries.

\end{itemize}

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cube.css}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cube}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{screen}\PYG{p}{;}
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http://cube.edu/style}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{k}{@import} \PYG{l+s+sx}{url(}\PYG{l+s+sx}{cube}\PYG{l+s+sx}{)}\PYG{p}{;}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}cube.css\PYGZdq{}}\PYG{p}{;}
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}cube\PYGZdq{}} \PYG{n+nt}{screen}\PYG{p}{;}
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}http://cube.edu/style\PYGZdq{}}\PYG{p}{;}
\PYG{k}{@import} \PYG{n+nt}{url}\PYG{o}{(}\PYG{n+nt}{cube}\PYG{o}{)}\PYG{p}{;}
\end{Verbatim}

If we want to import the file \emph{cube.scss} we can write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cube.scss}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\end{Verbatim}

or just simply

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cube}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\end{Verbatim}

If you want to import more files, it's possible to write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{first}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{second}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\end{Verbatim}

If you name the \emph{.scss} file with underscore before filename \emph{\_cube.scss}, then its code will be added to the main \emph{.css} file, but it will not be compiled to CSS file. In \emph{@import} you don't need to write the underscore, but it's important that in the same folder can not be  more files with the same name. (If in folder is \emph{cube.scss}, than you can not use \emph{\_cube.scss}). This type of naming of files is called partials.

One of earlier mentioned features of Sass is nesting and it's possible to use it with \emph{@import}.  Most of time you will use the \emph{@import} at the top of the document. But there can come situation when it would be handy to include whole another file into some class. At that case you can call \emph{@import} under class.

This is demonstrated in the example that follows. The \emph{box.scss} and \emph{screen.scss} contain following code

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Content of the box.scss}
\PYG{n+nc}{.}\PYG{n+nc}{box} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nb}{red}\PYG{p}{;}
    \PYG{n+nc}{.}\PYG{n+nc}{button} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{background}\PYG{o}{:} \PYG{l+m+mh}{\PYGZsh{}444}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Content of the screen.scss}
\PYG{n+nc}{.}\PYG{n+nc}{screen} \PYG{p}{\PYGZob{}}
    \PYG{k}{@import} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s2}{box.scss}\PYG{l+s+s2}{\PYGZsq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The compiled version is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.screen} \PYG{n+nc}{.box} \PYG{p}{\PYGZob{}}
    \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{red}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.screen} \PYG{n+nc}{.box} \PYG{n+nc}{.button} \PYG{p}{\PYGZob{}}
    \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}444}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

There are few exceptions. There exists directives that can be only at the base level of the document. So if you are calling \emph{@import} into selector than the imported file can not contain \emph{@mixin} and \emph{@charset}. It's not possible to @import in mixins and control directives.

\textbf{@media}

\emph{@media} directive can be used as defined in the plain CSS, but it has one extra capability - it can be nested in CSS rule.  If it appears nested, than it bubble to the base level, containing all selectors in which it's included. This approach helps to make your code readable if you are using the @media.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.}\PYG{n+nc}{sidebar} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{width}\PYG{o}{:} \PYG{l+m+mi}{300}\PYG{k+kt}{px}\PYG{p}{;}
    \PYG{k}{@media} \PYG{n+nt}{screen} \PYG{n+nt}{and} \PYG{o}{(}\PYG{n+nt}{orientation}\PYG{n+nd}{:} \PYG{n+nt}{landscape}\PYG{o}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{width}\PYG{o}{:} \PYG{l+m+mi}{500}\PYG{k+kt}{px}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.sidebar} \PYG{p}{\PYGZob{}}
    \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{300px}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{@media} \PYG{n+nt}{screen} \PYG{n+nt}{and} \PYG{o}{(}\PYG{n+nt}{orientation}\PYG{o}{:} \PYG{n+nt}{landscape}\PYG{o}{)} \PYG{p}{\PYGZob{}}
    \PYG{n+nc}{.sidebar} \PYG{p}{\PYGZob{}}
        \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{500px}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This way you don't break the flow of your selectors that are nested into each and again you don't need to repeat to writing the selector that you want to specify with @media. You can complain that you often write the value for the \emph{@media}, but we have variables. This is nice place where you can use it.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\$landscape: 'screen and (orientation: landscape)';

.sidebar \PYGZob{}
    width: 300px;
    @media \#\PYGZob{}\$landscape\PYGZcb{} \PYGZob{}
        width: 500px;
    \PYGZcb{}
\PYGZcb{}

.content \PYGZob{}
    width: 400px;
    @media \#\PYGZob{}\$landscape\PYGZcb{} \PYGZob{}
        width: 600px;
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@media} \PYG{n+nt}{screen} \PYG{n+nt}{and} \PYG{o}{(}\PYG{n+nt}{orientation}\PYG{o}{:} \PYG{n+nt}{landscape}\PYG{o}{)} \PYG{p}{\PYGZob{}}
    \PYG{n+nc}{.sidebar} \PYG{p}{\PYGZob{}}
        \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{500px}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n+nc}{.content} \PYG{p}{\PYGZob{}}
        \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{600px}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.sidebar} \PYG{p}{\PYGZob{}}
    \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{300px}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.content} \PYG{p}{\PYGZob{}}
    \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{400px}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can define  more @media properties for specific devices at the start and if you need to change some properties you don't need to look through documents where you write device-specific rules and no selectors were written twice.

\textbf{@extend}

There are often cases when you need to use the all rules from one selector and add only some new. Most used way how to do that is using some general class and than more specific class that sets the different properties. Than the HTML will be following

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}div} \PYG{n+na}{class=}\PYG{l+s}{\PYGZdq{}error error\PYGZhy{}login\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
    Sorry, bad login or password. Try it again.
\PYG{n+nt}{\PYGZlt{}/div\PYGZgt{}}
\end{Verbatim}

The css to the code will be

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.error} \PYG{p}{\PYGZob{}}
    \PYG{k}{border}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{solid} \PYG{l+m}{\PYGZsh{}FF5151}\PYG{p}{;}
    \PYG{k}{background\PYGZhy{}color}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}F9E9E9}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.error\PYGZhy{}login} \PYG{p}{\PYGZob{}}
    \PYG{k}{border\PYGZhy{}width}\PYG{o}{:} \PYG{k}{thick}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This approach is functional and it's often used, but you must not forgot the error class. The \emph{@extend} directive helps to avoid the some problems that are possible using this way. Than in the HTML will be written

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}div} \PYG{n+na}{class=}\PYG{l+s}{\PYGZdq{}error\PYGZhy{}login\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
    Sorry, bad login or password. Try it again.
\PYG{n+nt}{\PYGZlt{}/div\PYGZgt{}}
\end{Verbatim}

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.}\PYG{n+nc}{error} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{border}\PYG{o}{:} \PYG{n+no}{thin} \PYG{n+no}{solid} \PYG{l+m+mh}{\PYGZsh{}FF5151}\PYG{p}{;}
    \PYG{n+na}{background\PYGZhy{}color}\PYG{o}{:} \PYG{l+m+mh}{\PYGZsh{}F9E9E9}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.}\PYG{n+nc}{error\PYGZhy{}login} \PYG{p}{\PYGZob{}}
    \PYG{k}{@extend} \PYG{n+nc}{.}\PYG{n+nc}{error}\PYG{o}{;}
    \PYG{n+nt}{border\PYGZhy{}width}\PYG{n+nd}{:} \PYG{n+nt}{thick}\PYG{o}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.error}\PYG{o}{,} \PYG{n+nc}{.error\PYGZhy{}login} \PYG{p}{\PYGZob{}}
    \PYG{k}{border}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{solid} \PYG{l+m}{\PYGZsh{}FF5151}\PYG{p}{;}
    \PYG{k}{background\PYGZhy{}color}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}F9E9E9}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.error\PYGZhy{}login} \PYG{p}{\PYGZob{}}
    \PYG{k}{border\PYGZhy{}width}\PYG{o}{:} \PYG{k}{thick}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{@extend} works by inserting extending selector anywhere the extended selector appears. For better illustration I add an example.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.}\PYG{n+nc}{error} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{border}\PYG{o}{:} \PYG{n+no}{thin} \PYG{n+no}{solid} \PYG{n+nb}{red}\PYG{p}{;}
    \PYG{n+na}{padding}\PYG{o}{:} \PYG{l+m+mf}{.5}\PYG{k+kt}{em}\PYG{p}{;}
    \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nb}{red}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.}\PYG{n+nc}{error}\PYG{n+nc}{.}\PYG{n+nc}{icon} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{background}\PYG{o}{:} \PYG{l+s+sx}{url(}\PYG{l+s+sx}{\PYGZsq{}images/error.png\PYGZsq{}}\PYG{l+s+sx}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.}\PYG{n+nc}{error\PYGZhy{}login} \PYG{p}{\PYGZob{}}
    \PYG{k}{@expand} \PYG{n+nc}{.}\PYG{n+nc}{error}\PYG{o}{;}
    \PYG{n+nt}{font\PYGZhy{}weight}\PYG{n+nd}{:} \PYG{n+nt}{bold}\PYG{o}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.error}\PYG{o}{,} \PYG{n+nc}{.error\PYGZhy{}login} \PYG{p}{\PYGZob{}}
    \PYG{k}{border}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{solid} \PYG{n+nb}{red}\PYG{p}{;}
    \PYG{k}{padding}\PYG{o}{:} \PYG{l+m}{.5em}\PYG{p}{;}
    \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{red}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.error}\PYG{n+nc}{.icon}\PYG{o}{,} \PYG{n+nc}{.error\PYGZhy{}login}\PYG{n+nc}{.icon} \PYG{p}{\PYGZob{}}
    \PYG{k}{background}\PYG{o}{:} \PYG{l+s+sx}{url(\PYGZsq{}images/error.png\PYGZsq{})}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.error\PYGZhy{}login} \PYG{p}{\PYGZob{}}
    \PYG{k}{font\PYGZhy{}weight}\PYG{o}{:} \PYG{k}{bold}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

If you are familiar with Object Oriented languages such Java or C++ you sure know the meaning of abstract class or function. There are not allowed instances from abstract classes, so they must be inherited by another class. In Sass exists similar way to define the selector. It's called ``placeholder selectors''. They are defined in Sass version of code, but they are not compiled to the CSS. Only if they are extended by another selector. It helps to avoid names collisions and the in the output CSS they show up only if they are needed. They are most of time used if you are creating framework. The syntax difference from the selectors for classes and ids only in first characters. You don't use the \emph{.} or \emph{\#}, but \emph{\%}. So ``placeholder selector'' for the error could be \emph{\%error}. Everything else works like for normal selector.

The main difference between using extend and mixins is in the output CSS. Say that we want to create four buttons and only the color of the background would be changed. If you use mixins for that, the output would have the same code for every button generated and only the color codes would be different. On other hand, if you extend generic ``placeholder selector''  for buttons and set for each one only different color, than the generated CSS will have shorter code. In situation when you want to load your site as fast as possible is this approach good idea. But always this things depends on the situation.

If you want to use \emph{@extend} inside of the media block, there is some restrictions. You can extend only selectors that are inside of the media block.


\subsection{Mixins}
\label{src/sass:mixins}
Some of many advantages of Sass is keeping your code readable and don't repeating yourself. For the purpose of DRY (don't repeat yourself) mixins exist and like many things in Sass come from ``Ruby universe'', mixins exists there too. The way how mixins work is to include their code at the place where they were called.

\textbf{Defining a Mixin with {}`@mixin{}`}

Mixins are defined with the directive \emph{@mixin} following with the name of mixin and optionally the arguments. After that is there a block containing content of mixin closed into curly brackets.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@mixin}\PYG{n+nf}{ button} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{border}\PYG{o}{:} \PYG{n+no}{thin} \PYG{n+no}{solid} \PYG{l+m+mh}{\PYGZsh{}40AECA}\PYG{p}{;}
    \PYG{n+na}{background}\PYG{o}{:} \PYG{l+m+mh}{\PYGZsh{}85C7D8}\PYG{p}{;}
    \PYG{n+na}{border\PYGZhy{}radius}\PYG{o}{:} \PYG{l+m+mi}{5}\PYG{k+kt}{px}\PYG{p}{;}
    \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nb}{white}\PYG{p}{;}
    \PYG{k}{\PYGZam{}}\PYG{n+nd}{:}\PYG{n+nd}{hover} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{background}\PYG{o}{:} \PYG{l+m+mh}{\PYGZsh{}7EB7C6}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

If you try to compile this with sass, than the output will be empty. The reason is that you don't use the mixin. And the second thing what you can see at definition of mixin is \emph{\&:hover}. We met with it in nesting, but there we knew who was parent. Here will be the parent selector defined at the moment of calling the mixin.

For inserting the content of the mixin use \emph{@include} directive.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.}\PYG{n+nc}{button} \PYG{p}{\PYGZob{}}
    \PYG{k}{@include}\PYG{n+nd}{ button}\PYG{p}{;}
    \PYG{n+na}{height}\PYG{o}{:} \PYG{l+m+mi}{30}\PYG{k+kt}{px}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.button} \PYG{p}{\PYGZob{}}
    \PYG{k}{border}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{solid} \PYG{l+m}{\PYGZsh{}40AECA}\PYG{p}{;}
    \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}85C7D8}\PYG{p}{;}
    \PYG{k}{border}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{:} \PYG{l+m}{5px}\PYG{p}{;}
    \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{white}\PYG{p}{;}
    \PYG{k}{height}\PYG{o}{:} \PYG{l+m}{30px}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.button}\PYG{n+nd}{:hover} \PYG{p}{\PYGZob{}}
        \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}7EB7C6}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{Verbatim}

But this is not all what comes with mixins. I give you example when you need to have same styled buttons, but with different background colors. You can define the new color after \emph{@include button}, but there comes some repeating work. You must always define the new behavior for the hover state too. All because of using different color. How can we improve it? We can use the arguments that would be passed to the mixin. The best way how to explain it would be with example.

Say that you want to create three different color buttons. One would be normal with light gray background and would be for classic actions. Next on would be the error button that has red background and finally information button with blue background. And we want to define one mixin and then change just colors when we include it.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@mixin}\PYG{n+nf}{ button}\PYG{p}{(}\PYG{n+nv}{\PYGZdl{}color}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n+na}{border}\PYG{o}{:} \PYG{n+no}{thin} \PYG{n+no}{solid} \PYG{n+nv}{\PYGZdl{}color} \PYG{o}{\PYGZhy{}} \PYG{l+m+mh}{\PYGZsh{}222222}\PYG{p}{;}
    \PYG{n+na}{background}\PYG{o}{:} \PYG{n+nv}{\PYGZdl{}color}\PYG{p}{;}
    \PYG{n+na}{border\PYGZhy{}radius}\PYG{o}{:} \PYG{l+m+mi}{5}\PYG{k+kt}{px}\PYG{p}{;}
    \PYG{n+na}{color}\PYG{o}{:} \PYG{n+nb}{white}\PYG{p}{;}
    \PYG{n+na}{padding}\PYG{o}{:} \PYG{l+m+mi}{5}\PYG{k+kt}{px}\PYG{p}{;}
    \PYG{k}{\PYGZam{}}\PYG{n+nd}{:}\PYG{n+nd}{hover} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{background}\PYG{o}{:} \PYG{n+nv}{\PYGZdl{}color} \PYG{o}{\PYGZhy{}} \PYG{l+m+mh}{\PYGZsh{}161616}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.}\PYG{n+nc}{button} \PYG{p}{\PYGZob{}}
    \PYG{k}{@include}\PYG{n+nd}{ button}\PYG{p}{(}\PYG{l+m+mh}{\PYGZsh{}B1B1B1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.}\PYG{n+nc}{error\PYGZhy{}button} \PYG{p}{\PYGZob{}}
    \PYG{k}{@include}\PYG{n+nd}{ button}\PYG{p}{(}\PYG{l+m+mh}{\PYGZsh{}FB4242}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.}\PYG{n+nc}{info\PYGZhy{}button} \PYG{p}{\PYGZob{}}
    \PYG{k}{@include}\PYG{n+nd}{ button}\PYG{p}{(}\PYG{l+m+mh}{\PYGZsh{}549EE5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.button} \PYG{p}{\PYGZob{}}
  \PYG{k}{border}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{solid} \PYG{l+m}{\PYGZsh{}8f8f8f}\PYG{p}{;}
  \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}b1b1b1}\PYG{p}{;}
  \PYG{k}{border}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{:} \PYG{l+m}{5px}\PYG{p}{;}
  \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{white}\PYG{p}{;}
  \PYG{k}{padding}\PYG{o}{:} \PYG{l+m}{5px}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
  \PYG{n+nc}{.button}\PYG{n+nd}{:hover} \PYG{p}{\PYGZob{}}
    \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}9b9b9b}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.error\PYGZhy{}button} \PYG{p}{\PYGZob{}}
  \PYG{k}{border}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{solid} \PYG{l+m}{\PYGZsh{}d92020}\PYG{p}{;}
  \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}fb4242}\PYG{p}{;}
  \PYG{k}{border}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{:} \PYG{l+m}{5px}\PYG{p}{;}
  \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{white}\PYG{p}{;}
  \PYG{k}{padding}\PYG{o}{:} \PYG{l+m}{5px}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
  \PYG{n+nc}{.error\PYGZhy{}button}\PYG{n+nd}{:hover} \PYG{p}{\PYGZob{}}
    \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}e52c2c}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.info\PYGZhy{}button} \PYG{p}{\PYGZob{}}
  \PYG{k}{border}\PYG{o}{:} \PYG{k}{thin} \PYG{k}{solid} \PYG{l+m}{\PYGZsh{}327cc3}\PYG{p}{;}
  \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}549ee5}\PYG{p}{;}
  \PYG{k}{border}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{:} \PYG{l+m}{5px}\PYG{p}{;}
  \PYG{k}{color}\PYG{o}{:} \PYG{n+nb}{white}\PYG{p}{;}
  \PYG{k}{padding}\PYG{o}{:} \PYG{l+m}{5px}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
  \PYG{n+nc}{.info\PYGZhy{}button}\PYG{n+nd}{:hover} \PYG{p}{\PYGZob{}}
    \PYG{k}{background}\PYG{o}{:} \PYG{l+m}{\PYGZsh{}3e88cf}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Knowledge of this techniques is enough for you to start using the Sass on daily basis. There exists some more advanced things that comes handy, but their main purpose is for make more flexible code that can be part of framework like Compass. If you work on large projects and you use some styling techniques often, than it could be good idea to invest some time to write them into simple framework for you and use it in your projects, but before you start writing everything on your own, it could be good idea to jump to the chapter about Compass and look if things that you need do exist in it.


\subsection{Control Directives}
\label{src/sass:control-directives}
SassScript supports control directives for including styles only under specific condition or including same style several times with variations. Their main purpose is to use them in mixins, those that are part libraries like Compass and requires flexibility.

\textbf{@if}

\emph{IF} is one of the basics directives for control the flow. The style would be applied only if the condition returns anything else than \emph{false} or \emph{null}.  In conditions are allowed logical operations \emph{and} and \emph{or} that require at least two conditions and the negation \emph{not}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{p} \PYG{p}{\PYGZob{}}
    \PYG{k}{@if} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{==} \PYG{l+m+mi}{2} \PYG{p}{\PYGZob{}} \PYG{n+na}{border}\PYG{o}{:} \PYG{l+m+mi}{1}\PYG{k+kt}{px} \PYG{n+no}{solid}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k}{@if} \PYG{n+nf}{not}\PYG{p}{(}\PYG{l+m+mi}{5} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3}\PYG{p}{)}   \PYG{p}{\PYGZob{}} \PYG{n+na}{border}\PYG{o}{:} \PYG{l+m+mi}{2}\PYG{k+kt}{px} \PYG{n+no}{dotted}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k}{@if} \PYG{n}{null}             \PYG{p}{\PYGZob{}} \PYG{n+na}{border}\PYG{o}{:} \PYG{l+m+mi}{4}\PYG{k+kt}{px} \PYG{n+no}{dashed}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{p} \PYG{p}{\PYGZob{}} \PYG{k}{border}\PYG{o}{:} \PYG{l+m}{1px} \PYG{k}{solid}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

At case that you need to check if the variable content is one of many, than comes handy the \emph{@else if}. The last must be \emph{@else}.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\$language: ruby;
p \PYGZob{}
    @if \$language == python \PYGZob{}
        background: green;
    \PYGZcb{} @else if \$language == c\# \PYGZob{}
        background: blue;
    \PYGZcb{} @else if \$language == ruby \PYGZob{}
        background: red;
    \PYGZcb{} @else \PYGZob{}
        background: yellow;
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{p} \PYG{p}{\PYGZob{}} \PYG{k}{background}\PYG{o}{:} \PYG{n+nb}{red}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

\textbf{@for}

In case that you need to repeat some action with different value in the output, you can use \emph{@for} loop. It sets the value in variable from starting point to end. There are two forms of for-loop in Sass. First is \emph{@for \$var from \textless{}start\textgreater{} through \textless{}end\textgreater{}} and the second is \emph{@for \$var from \textless{}start\textgreater{} to \textless{}end\textgreater{}}. The variable \emph{\$var} is normal variable that can be named arbitrarily. It's common to name it \emph{\$i}. The \emph{\textless{}start\textgreater{}} and \emph{\textless{}end\textgreater{}} can be any expressions that return integer. The difference between these two forms is in the \emph{trough} and \emph{to}. If you use \emph{through} the \emph{\textless{}end\textgreater{}} value will be used at the end. If you use \emph{to} the loop stops at the \emph{\textless{}end\textgreater{}-1} value.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@for} \PYG{n+nv}{\PYGZdl{}i} \PYG{o+ow}{from} \PYG{l+m+mi}{1} \PYG{o+ow}{to} \PYG{l+m+mi}{4} \PYG{p}{\PYGZob{}}
    \PYG{n+nc}{.}\PYG{n+nc}{item\PYGZhy{}}\PYG{l+s+si}{\PYGZsh{}\PYGZob{}}\PYG{n+nv}{\PYGZdl{}i}\PYG{l+s+si}{\PYGZcb{}} \PYG{p}{\PYGZob{}} \PYG{n+na}{width}\PYG{o}{:}  \PYG{l+m+mi}{2}\PYG{k+kt}{em} \PYG{o}{*} \PYG{n+nv}{\PYGZdl{}i}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.item\PYGZhy{}1} \PYG{p}{\PYGZob{}} \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{2em}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.item\PYGZhy{}2} \PYG{p}{\PYGZob{}} \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{4em}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.item\PYGZhy{}3} \PYG{p}{\PYGZob{}} \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{6em}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

\textbf{@each}

The for-loop is good if you are working with numbers. But if you want to work with list of words, than using the \emph{@each} is better decision.  The syntax for each is simple. \emph{@each \$var in \textless{}list\textgreater{}}. The variable \emph{\$var} is working the same way how in the for-loop. So in every step the \emph{\$var} value is equal to one of the items in the list.

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
@each \$shape in circle, triangle, square \PYGZob{}
    .\#\PYGZob{}\$shape\PYGZcb{}-icon \PYGZob{}
        background-image: url('/images/\#\PYGZob{}\$shape\PYGZcb{}.png');
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.circle\PYGZhy{}icon} \PYG{p}{\PYGZob{}} \PYG{k}{background\PYGZhy{}image}\PYG{o}{:} \PYG{l+s+sx}{url(\PYGZdq{}/images/circle.png\PYGZdq{})}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.triangle\PYGZhy{}icon} \PYG{p}{\PYGZob{}} \PYG{k}{background\PYGZhy{}image}\PYG{o}{:} \PYG{l+s+sx}{url(\PYGZdq{}/images/triangle.png\PYGZdq{})}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.square\PYGZhy{}icon} \PYG{p}{\PYGZob{}} \PYG{k}{background\PYGZhy{}image}\PYG{o}{:} \PYG{l+s+sx}{url(\PYGZdq{}/images/square.png\PYGZdq{})}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

\textbf{@while}

If the step one that is in the for-loop is not good for you, than you must use the while. It will run until the condition is true. The syntax is as showed here:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@while} \PYG{n}{condition} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// code}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

And example

\emph{.scss}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{}i}\PYG{o}{:} \PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k}{@while} \PYG{n+nv}{\PYGZdl{}i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{p}{\PYGZob{}}
    \PYG{n+nc}{.}\PYG{n+nc}{box\PYGZhy{}}\PYG{l+s+si}{\PYGZsh{}\PYGZob{}}\PYG{n+nv}{\PYGZdl{}i}\PYG{l+s+si}{\PYGZcb{}} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{width}\PYG{o}{:} \PYG{l+m+mi}{2}\PYG{k+kt}{em} \PYG{o}{*} \PYG{n+nv}{\PYGZdl{}i}\PYG{p}{;}
        \PYG{n+nv}{\PYGZdl{}i}\PYG{o}{:} \PYG{n+nv}{\PYGZdl{}i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\emph{.css}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.box\PYGZhy{}6} \PYG{p}{\PYGZob{}} \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{12em}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.box\PYGZhy{}4} \PYG{p}{\PYGZob{}} \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{8em}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.box\PYGZhy{}2} \PYG{p}{\PYGZob{}} \PYG{k}{width}\PYG{o}{:} \PYG{l+m}{4em}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}


\chapter{Compass}
\label{src/compass::doc}\label{src/compass:compass}
At this point you should know enough about Sass and what is possible to do in it. There are many ways how to use it. You can use the approach of writing everything for yourself and only if you need it. There are probably some of you who always work this way. But many developers want to save time to start with next project. They often take some framework, that has the common things written and they just write the new parts specific for their project. The community about Sass is not different. There is not just one framework that you can use, but in this tutorial I will talk about the oldest and probably the most used of them. Compass.

If you have some time to spare and learn something more, than I recommend to go through the code of the Compass, that you can find in it's public repository on the GitHub: \href{https://github.com/chriseppstein/compass}{github.com/chriseppstein/compass} (https://github.com/chriseppstein/compass). There are more than just Sass code, while Compass has own tools to create projects. Important for you is to target the framework and then compass folder, where you can find only styles written in Sassy CSS (.scss).


\section{Installation}
\label{src/compass:installation}
Installation of this framework is simple. Important is to have installed Sass. If you for some reason don't, than go to the chapter about Sass, where is written the guide for installation. Put following command into console:

\begin{Verbatim}[commandchars=\\\{\}]
gem install compass
\end{Verbatim}

There is possibility that on the UNIX/Linux systems will you need to add \emph{sudo} before the command, while it will want to write into protected folders own data. It will download and set up path to compass files and prepare it to using for you.


\section{Working with projects}
\label{src/compass:working-with-projects}
In every project in which you want to use the Compass, you need to have configuration file, that says to the compiler where to look for files, where to save the output and some other options important for work. For all that there is command line tool called simply \emph{compass}. I'm not going through all it's options, only the primary. If you want to see all options use option for help. In case that you need something, that it's not written in following text, I recommend the \href{http://compass-style.org/help/tutorials/}{Compass Tutorials} (http://compass-style.org/help/tutorials/), where are covered even more advance topics.

\begin{Verbatim}[commandchars=\\\{\}]
compass \PYGZhy{}h
\end{Verbatim}

Now if you have some time try to look at the list of all options that compass has. I'm going to explain the primary ones and what they do.

\textbf{create}

The most important is to create new Compass project. It's done with the option \emph{create}. After the option follows the name of the project.

\begin{Verbatim}[commandchars=\\\{\}]
compass create HelloWorld
\end{Verbatim}

The start of its output will be following

\begin{Verbatim}[commandchars=\\\{\}]
directory HelloWorld/
directory HelloWorld/sass/
directory HelloWorld/stylesheets/
create HelloWorld/config.rb
create HelloWorld/sass/screen.scss
create HelloWorld/sass/print.scss
create HelloWorld/sass/ie.scss
create HelloWorld/stylesheets/print.css
create HelloWorld/stylesheets/screen.css
create HelloWorld/stylesheets/ie.css
\end{Verbatim}

It creates the folder HelloWorld with \emph{config.rb}, in that is stored the settings that will be used by the compass compiler, and two folders one for yours Sass code - \emph{sass} and one for generated css called \emph{stylesheets}. It even creates three \emph{.scss} files for your styles and compile them to their CSS versions. At the end of the output is how to include the styles to your HTML or some similar document, where you need the styles, but this you should know.

The names of the files don't need to be equal to the version generated by compass. Only the \emph{config.rb} file name needs to stay without change. It stores the settings for the compiler where to look for the sass files and where save the output. It even sets where are saved images that you use and your javascript if you have any.

Content of the \emph{config.rb}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Require any additional compass plugins here.}

\PYG{c}{\PYGZsh{} Set this to the root of your project when deployed:}
\PYG{n}{http\PYGZus{}path} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{css\PYGZus{}dir} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{stylesheets}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{sass\PYGZus{}dir} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sass}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{images\PYGZus{}dir} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{images}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{javascripts\PYGZus{}dir} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{javascripts}\PYG{l+s}{\PYGZdq{}}

\PYG{c}{\PYGZsh{} You can select your preferred output style here}
\PYG{c}{\PYGZsh{} (can be overridden via the command line):}
\PYG{c}{\PYGZsh{} output\PYGZus{}style = :expanded or :nested or :compact or :compressed}

\PYG{c}{\PYGZsh{} To enable relative paths to assets via compass helper}
\PYG{c}{\PYGZsh{} functions. Uncomment:}
\PYG{c}{\PYGZsh{} relative\PYGZus{}assets = true}

\PYG{c}{\PYGZsh{} To disable debugging comments that display the original}
\PYG{c}{\PYGZsh{} location of your selectors. Uncomment:}
\PYG{c}{\PYGZsh{} line\PYGZus{}comments = false}
\end{Verbatim}

There are comments that explain a lot of things, if you are not sure what does some option mean. You are probably not going to change a lot of the code in here. Only at the time of deployment of the project is nice to uncomment the \emph{line\_comments} (just delete the hash sign \emph{\#}) and set the \emph{output\_style} to \emph{:compressed}. This way will compass generate for you the smallest version of your style.

\textbf{init}

If you had started some project and later you figure out that you need to use Compass, than comes the \emph{init} option handy. It create all important files for compass in the directory where is your project. Enter the folder with your project. For example, it's called \emph{web\_app} and run following command.

\begin{Verbatim}[commandchars=\\\{\}]
compass init
\end{Verbatim}

After that you are done. It created \emph{config.rb} and the folders for the sass styles and generated CSS. You can say that you can create it on your own, while it's just one configuration file and few folders. But \emph{init} makes it for you.

\textbf{compile}

Probably the most important option. It looks at the configuration file and base on the settings it generates CSS from your Sass.

\begin{Verbatim}[commandchars=\\\{\}]
compass compile \PYG{o}{[}/path/to/project\PYG{o}{]}
\end{Verbatim}

If you are in the same directory as is the \emph{config.rb} file, than the path won't be there. The path to project is important if you in other directory as the configuration file.

\textbf{watch}

This option will be used most of the time. It does the same thing as the \emph{compile} with one feature at the top. It waits for changes of your sass code and if there are any, \emph{watch} will compile your code automatically.

\begin{Verbatim}[commandchars=\\\{\}]
compass watch \PYG{o}{[}/path/to/project\PYG{o}{]}
\end{Verbatim}

Again the path is important only in case that you are not in the same directory as is the \emph{config.rb} file.


\section{Compass core}
\label{src/compass:compass-core}
The Compass library is created from two frameworks at the time of writing. The one is the core of the Compass about which would be this section. Another is the Blueprint framework. I'm not going to talk about the Blueprint while it will be deprecated from newer versions of Sass. If you need some toolkit to work with grid and layouts, than I recommend to look at the \href{http://susy.oddbird.net/}{Susy} (http://susy.oddbird.net/). It's build with the Sass and works nice with Compass.

The Compass core is spliced into six parts.
\begin{itemize}
\item {} 
CSS3 - how the name suggests it contains mixins to make life with CSS3 easier

\item {} 
Typography

\item {} 
Utilities

\item {} 
Layout

\item {} 
Reset - global reset based on the \href{http://meyerweb.com/eric/tools/css/reset/index.html}{Eric Meyer's reset 2.0} (http://meyerweb.com/eric/tools/css/reset/index.html)

\item {} 
Helpers - functions that add new functions to existing in the SassScript

\end{itemize}

Each one will be dedicated own section where I go through the features that it has. If you need only to find something specific and you don't need comments for it than I recommend the Compass reference at \href{http://compass-style.org/reference/compass/}{Compass Reference} (http://compass-style.org/reference/compass/).

Easiest way how to start using Compass is to use

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{compass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\end{Verbatim}

After that you can access everything included in the CSS3, typography and utilities category.


\subsection{Reset}
\label{src/compass:reset}
All browsers have default styles that are called if the site has not own stylesheet for required element. With one small problem. They have slightly different predefined styles for some elements, so for example the padding for \emph{div} haven't have to be the same. And there are many different places when you need no padding and margins defined. For that most of the developers specify at the begin of the CSS the `reset' rules.  Because this is often done, Compass has built-in support for it. Just at the begin of Sass code include the reset and it will append the global reset based on the \href{http://meyerweb.com/eric/tools/css/reset/index.html}{Eric Meyer's reset 2.0} (http://meyerweb.com/eric/tools/css/reset/index.html).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{compass/reset}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\end{Verbatim}

If you need specific version only for some elements only include utilities from the reset. Most of the time you will use the global reset, if not than at \href{http://compass-style.org/reference/compass/reset/utilities/}{Reset Utilities} (http://compass-style.org/reference/compass/reset/utilities/) you can find the reference for mixins for more specified reset.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{compass/reset/utilities}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\end{Verbatim}


\subsection{CSS3}
\label{src/compass:css3}
The CSS3 brings many new features to modern browser. From basic things like border radius through box-shadow to advance effects created with transitions and key-frames. Everything would be great if CSS3 would be completed and all features in it implemented in all browsers the same way. But this is just wish of all web-developers. Truth is that browsers came with their own prefixes for function of CSS3 which has not yet been accepted to the final version or they have their own ideas that they want to make their browser more advance for example.

Every web-developer today must have seen vendor prefixes like -webkit-, -ms-, -mz- and -o-. If you need to create button, that drops shadow, in perfect universe you will write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.perfect\PYGZhy{}button} \PYG{p}{\PYGZob{}}
    \PYG{o}{...}
    \PYG{n}{box}\PYG{o}{\PYGZhy{}}\PYG{n}{shadow}\PYG{o}{:} \PYG{l+m}{2px} \PYG{l+m}{2px} \PYG{l+m}{5px} \PYG{l+m}{4px} \PYG{n}{rgba}\PYG{p}{(}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{0}\PYG{o}{.}\PYG{l+m}{8}\PYG{p}{);}
    \PYG{o}{...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

But in this world you must write something like

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.just\PYGZhy{}button} \PYG{p}{\PYGZob{}}
    \PYG{o}{...}
    \PYG{o}{\PYGZhy{}}\PYG{n}{webkit}\PYG{o}{\PYGZhy{}}\PYG{n}{box}\PYG{o}{\PYGZhy{}}\PYG{n}{shadow}\PYG{o}{:} \PYG{l+m}{2px} \PYG{l+m}{2px} \PYG{l+m}{5px} \PYG{l+m}{4px} \PYG{n}{rgba}\PYG{p}{(}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{0}\PYG{o}{.}\PYG{l+m}{8}\PYG{p}{);}
       \PYG{o}{\PYGZhy{}}\PYG{n}{moz}\PYG{o}{\PYGZhy{}}\PYG{n}{box}\PYG{o}{\PYGZhy{}}\PYG{n}{shadow}\PYG{o}{:} \PYG{l+m}{2px} \PYG{l+m}{2px} \PYG{l+m}{5px} \PYG{l+m}{4px} \PYG{n}{rgba}\PYG{p}{(}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{0}\PYG{o}{.}\PYG{l+m}{8}\PYG{p}{);}
            \PYG{n}{box}\PYG{o}{\PYGZhy{}}\PYG{n}{shadow}\PYG{o}{:} \PYG{l+m}{2px} \PYG{l+m}{2px} \PYG{l+m}{5px} \PYG{l+m}{4px} \PYG{n}{rgba}\PYG{p}{(}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{42}\PYG{o}{,}\PYG{l+m}{0}\PYG{o}{.}\PYG{l+m}{8}\PYG{p}{);}
    \PYG{o}{...}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This is one of the better cases when there not all browsers have their own prefixes. But we need to add two more lines just to secure that it will work in as many browsers as possible. Finally the same example written in Sass using Compass.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{compass/css3}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{o}{.}\PYG{n}{scss\PYGZhy{}button} \PYG{p}{\PYGZob{}}
    \PYG{n+nc}{.}\PYG{n+nc}{.}\PYG{n+nc}{.}
    \PYG{o}{@}\PYG{n+nt}{include} \PYG{n+nt}{box\PYGZhy{}shadow}\PYG{o}{(}\PYG{n+nt}{rgba}\PYG{o}{(}\PYG{n+nt}{42}\PYG{o}{,}\PYG{n+nt}{42}\PYG{o}{,}\PYG{n+nt}{42}\PYG{o}{,}\PYG{n+nt}{0}\PYG{n+nc}{.}\PYG{n+nc}{8}\PYG{o}{)} \PYG{n+nt}{2px} \PYG{n+nt}{2px} \PYG{n+nt}{5px} \PYG{n+nt}{4px}\PYG{o}{)}\PYG{o}{;}
    \PYG{n+nc}{.}\PYG{n+nc}{.}\PYG{n+nc}{.}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The import is needed only once so I will not count it. We are again at one line for the box-shadow. The code with vendor prefixes will be generated by mixin defined in Compass. I'm not going to write specifically about mixins defined in the Compass, while they can change through time. For the most updated version visit their site with \href{http://compass-style.org/reference/compass/css3/}{Compass CSS3 reference} (http://compass-style.org/reference/compass/css3/).


\subsection{Helpers}
\label{src/compass:helpers}
The Sass comes with huge library of functions and the Compass helpers section extends it. The full reference of it is at \href{http://compass-style.org/reference/compass/helpers/}{Compass Helpers} (http://compass-style.org/reference/compass/helpers/). I don't think that you would ever need all of them in one project. But few  of them can save a lot work so you will be using them more frequently.

It can happen that through development of the web application are two groups. One is coding the back-end with all logic and interactions and the second is aimed on the front-end and working on the styles. It can happen that at the deployment changes are made to the paths for the images. If you are using just CSS, you must go through code and change the occurrence of the problems. In helpers there exists function

\begin{Verbatim}[commandchars=\\\{\}]
image-url(\$path, [\$only-path])
\end{Verbatim}

It looks into the \emph{config.rb} file and takes the images\_dir value. For example I have image called \emph{smiley.png}, that is saved in the folder \emph{images} in the project.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.}\PYG{n+nc}{avatar} \PYG{p}{\PYGZob{}}
        \PYG{n+na}{background}\PYG{o}{:} \PYG{n+nf}{image\PYGZhy{}url}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s2}{smiley.png}\PYG{l+s+s2}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{\PYGZam{}}\PYG{n+nd}{:}\PYG{n+nd}{after} \PYG{p}{\PYGZob{}}
                \PYG{n+na}{content}\PYG{o}{:} \PYG{n+nf}{image\PYGZhy{}url}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s2}{smiley.png}\PYG{l+s+s2}{\PYGZsq{}}\PYG{o}{,} \PYG{n+nPseudo}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.avatar} \PYG{p}{\PYGZob{}}
        \PYG{k}{background}\PYG{o}{:} \PYG{n}{image}\PYG{o}{\PYGZhy{}}\PYG{l+s+sx}{url(\PYGZsq{}/images/smiley.png\PYGZsq{})}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.avatar}\PYG{n+nd}{:after} \PYG{p}{\PYGZob{}}
        \PYG{k}{content}\PYG{o}{:} \PYG{l+s+s2}{\PYGZdq{}/images/smiley.png\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

How can you see there is slightly difference, if you set the second argument to \emph{true}. Than it will omit the \emph{url()} in the output. The similar functions exist for the fonts. Only difference is in the name \emph{font-url}.

Next useful function is for dimensions of the images. If you need to know the dimensions of the image, compass comes with functionality for that.

\begin{Verbatim}[commandchars=\\\{\}]
image-height(\$image);

image-width(\$image);
\end{Verbatim}

The image is relative path of the image. Another tool for images is the function

\begin{Verbatim}[commandchars=\\\{\}]
inline-images(\$image, [\$mime-type]);
\end{Verbatim}

I recommend to use it only for small images, like icons, where it can save the HTTP request, with little larger CSS file.


\subsection{Utilities}
\label{src/compass:utilities}
The Compass Utilities brings mixins for some common tasks. There are utility for control what will be in the print version displayed or if you need to fast way to style table that you can use \emph{@import ``compass/utilities/tables'';} example can be find at \href{http://compass-style.org/examples/compass/tables/all/}{Table utility example} (http://compass-style.org/examples/compass/tables/all/).

At last I would like to show you how to work with sprites in the Compass. The reason for using sprites is to save HTTP request and speedup the load of the site. They are most of time used if you have many small icons. Without using sprites every one image must be loaded separately. With sprites it loads all images and that using CSS use only needed.

In our example we have all 3 icons for social networks with dimensions 32x32 pixels saved in the directory \emph{social}.

\begin{Verbatim}[commandchars=\\\{\}]
images/icons/social/fb.png
images/icons/social/gplus.png
images/icons/social/tweet.png
\end{Verbatim}

I will show you the basic and easiest way how to create sprite. At the top of your Sass file put

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{@import} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{icons/social/*.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{k}{@import} \PYG{n}{all\PYGZhy{}social\PYGZhy{}sprites}\PYG{p}{;}
\end{Verbatim}

It will generate

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nc}{.social\PYGZhy{}fb}\PYG{o}{,}
\PYG{n+nc}{.social\PYGZhy{}gplus}\PYG{o}{,}
\PYG{n+nc}{.social\PYGZhy{}tweet} \PYG{p}{\PYGZob{}} 
\PYG{k}{background}\PYG{o}{:} \PYG{l+s+sx}{url(\PYGZsq{}/images/icons/social\PYGZhy{}s34fe0232ab.png\PYGZsq{})} \PYG{k}{no\PYGZhy{}repeat}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

\PYG{n+nc}{.social\PYGZhy{}fb} \PYG{p}{\PYGZob{}} \PYG{k}{background\PYGZhy{}position}\PYG{o}{:} \PYG{l+m}{0} \PYG{l+m}{0}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.social\PYGZhy{}gplus}   \PYG{p}{\PYGZob{}} \PYG{k}{background\PYGZhy{}position}\PYG{o}{:} \PYG{l+m}{0} \PYG{l+m}{\PYGZhy{}32px}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{n+nc}{.social\PYGZhy{}tweet}    \PYG{p}{\PYGZob{}} \PYG{k}{background\PYGZhy{}position}\PYG{o}{:} \PYG{l+m}{0} \PYG{l+m}{\PYGZhy{}64px}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

The numbers in the name of the generated sprite will you get different. If you want to learn more about the generating sprites in the Compass, than read \href{http://compass-style.org/help/tutorials/spriting/}{Tutorial about sprites at Compass} (http://compass-style.org/help/tutorials/spriting/).
\chapter*{Conclusion}
      \addcontentsline{toc}{chapter}{Conclusion}

      \paragraph{}
      This tutorial should have learn you enough about Sass to start working with it on daily basis. At first it shows you how to obtain the Sass compiler and install it. Than it follows with the explaining the syntax and possibilities of the Sass. For each topic is simple example code. In second chapter moves our attention to the Compass framework. It is explained how to work with the project and where you can find more informations about it. Finaly, this tutorial looks at the Compass core and explain in my opinion important parts of it.

\renewcommand{\indexname}{Index}
\printindex


\bibliographystyle{plain} %cisla
%\bibliographystyle{alpha} %autor+rok
\bibliography{bibliography}
\end{document}
